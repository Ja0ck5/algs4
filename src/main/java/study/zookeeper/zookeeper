


## 节点类型
　　zk中的节点称之为znode（也叫data register，也就是存储数据的文件夹），按其生命周期的长短可以分为持久结点(PERSISTENT)和临时结点(EPHEMERAL);在创建时还可选择是否由Zookeeper服务端在其路径后添加一串序号用来区分同一个父结点下多个结点创建的先后顺序。
　　经过组合就有以下4种Znode结点类型：

```text

persistent：永久性znode。
ephemeral: 随着创建的客户端关闭而自动删除，不过它们仍然对所有客户端可见，ephemeral节点不允许有子节点。是实现分布式协调的核心机制。
sequential：附属于上述两类节点，是一种特性。在创建时，zookeeper会在其名字上分配一个序列号
```


## zookeeper的一致性保证
```text

1. 所有更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行
2. 数据更新原子性，一次数据更新要么成功，要么失败
3. 全局唯一数据视图，client无论连接到哪个server，数据视图都是一致的，基于所有写请求全部由leader完成，然后同步实现
4. 实时性，在一定时间范围内，client能读到最新数据
```


## zookeeper的其他核心机制

Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。
为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。
每个Server在工作过程中有三种状态：
LOOKING：当前Server不知道leader是谁，正在搜寻
LEADING：当前Server即为选举出来的leader
FOLLOWING：leader已经选举出来，当前Server与之同步


## watch机制
　　watch是zookeeper针对节点的一次性观察者机制（即一次触发后就失效，需要手工重新创建watch），行为上类似于数据库的触发器。

　　当watch监视的数据发生时，通知设置了该watch的client，客户端即watcher。watcher的机制是监听数据发生了某些变化，所以一定会有对应的事件类型和状态类型，一个客户端可以监控多个节点，在代码中体现在new了几个就产生几个watcher，只要节点变化都会执行一遍process。其示意图如下：



## Paxos

```text

分布式系统的一致性实现算法之paxos
　　paxos算法基于这样的原理：

　　• 在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。
　　• Paxos算法解决的什么问题呢，解决的就是保证每个节点执行相同的操作序列。好吧，这还不简单，master维护一个
　　   全局写队列，所有写操作都必须 放入这个队列编号，那么无论我们写多少个节点，只要写操作是按编号来的，就能保证一
　　　致性。没错，就是这样，可是如果master挂了呢。
　　• Paxos算法通过投票来对写操作进行全局编号，同一时刻，只有一个写操作被批准，同时并发的写操作要去争取选票，
　　　只有获得过半数选票的写操作才会被 批准（所以永远只会有一个写操作得到批准），其他的写操作竞争失败只好再发起一
　　　轮投票，就这样，在日复一日年复一年的投票中，所有写操作都被严格编号排 序。编号严格递增，当一个节点接受了一个
　　　编号为100的写操作，之后又接受到编号为99的写操作（因为网络延迟等很多不可预见原因），它马上能意识到自己 数据
　　　不一致了，自动停止对外服务并重启同步过程。任何一个节点挂掉都不会影响整个集群的数据一致性（总2n+1台，除非挂掉大于n台）
因此在生产中，要求zookeeper部署3（单机房）或5（单机房或多机房）或7（跨机房）个节点的集群。
```




